{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"This, is microq","text":"<p>microq is a tiny MQTT broker written in Go. It is inspired by several mature messaging systems such as NATS, Kafka, ActiveMQ etc.</p>"},{"location":"#vision","title":"Vision","text":""},{"location":"#messaging-should-be-easy","title":"Messaging should be easy","text":"<p>Developers should be able to onboard microq and start writing code without the need to unlearn their current messaging experience. microq will be cloud compatible, but you don't need to have Kubernetes running. You will be able to run microq anywhere from a Raspberry Pi, to a traditional Linux Desktop, a gigantic public cloud machine, an IBM-Z server, and of course, Kubernetes.</p>"},{"location":"#messaging-should-be-based-on-open-standards","title":"Messaging should be based on open standards","text":"<p>When messaging systems are built on open standards, it grows the ecosystem instead of dividing it. microq will always be based on multiple open standards and transports.</p>"},{"location":"#knowledge-is-best-when-shared","title":"Knowledge is best when shared","text":"<p>There will never be an enterprise, or premium flavor of microq. It is MIT Licensed - you are free to use it however you wish to.</p>"},{"location":"about/","title":"About","text":"<p>microq is a tiny MQTT broker written in Go with a focus on minimalism.</p> <p>Hence, the minimal content here, too.</p> <p></p>"},{"location":"configuration/","title":"Configuration","text":"<p>microq can be configured via a custom JSON configuration, and the path can be passed over via the <code>CONFIG_FILE_PATH</code> environment variable. The current JSON schema to be adhered to, can be found at c16a/microq:/config/config.go</p> <p>When running on Docker or Kubernetes, this file should be mounted as a volume.</p>"},{"location":"docker-build/","title":"Using Docker","text":"<p>microq uses a multi stage docker build for hermetic builds, while creating a minimal image. Hence, please ensure you use Docker v17.05 or newer.</p> <pre><code>git clone https://github.com/c16a/microq.git\ncd microq\ndocker build -t microq .\n</code></pre>"},{"location":"docker-build/#running-the-image","title":"Running the image","text":"<pre><code>docker run -p 8080:8080 -v $pwd/config.json:/app/config.json microq\n</code></pre> <p>The above example assumes that the TCP server has been configured to listen on port 8080. In case that is configured to another port, please configure the docker exposed port accordingly.</p>"},{"location":"docker-build/#selinux-policies","title":"SELinux policies","text":"<p>When using Docker on a host with SELinux enabled, the container is denied access to certain parts of host file system unless it is run in privileged mode. To resolve this, you can use a named volume</p> <pre><code># Create a docker volume and map it to /tmp/microq on the host\ndocker volume create --driver local --opt type=none --opt device=/tmp/microq --opt o=bind microq_volume\n\n# Ensure /tmp/microq/config.json has the required broker configuration\n# Use the above created microq_volume to mount the config file into the container\ndocker run -p 8080:8080 -e CONFIG_FILE_PATH=/tmp/microq/config.json --mount source=microq_volume,target=/tmp/microq microq\n</code></pre> <p>Please note that however, you place your <code>config.json</code> in the <code>/tmp</code> directory, SELinux does not restrict you access when you use a direct volume mapping.</p> <pre><code># This won't work with SELinux enabled\ndocker run -p 8080:8080 -e CONFIG_FILE_PATH=/tmp/microq/config.json -v /home/user/config.json:/tmp/microq/config.json microq\n\n# This will work\ndocker run -p 8080:8080 -e CONFIG_FILE_PATH=/tmp/microq/config.json -v /tmp/microq/config.json:/tmp/microq/config.json microq\n</code></pre> <p>The Configuration section has more details on which attributes of the broker can be configured.</p>"},{"location":"docker-build/#running-in-compose-mode","title":"Running in Compose mode","text":"<p>Create the named volume <code>microq_volume</code>.</p> <pre><code># Create a docker volume and map it to /tmp/microq on the host\ndocker volume create --driver local --opt type=none --opt device=/tmp/microq --opt o=bind microq_volume\n</code></pre> <p>Reference the named volume for the service</p> <pre><code>version: \"3.9\"\nservices:\n  broker:\n    build:\n      context: .\n    environment:\n      CONFIG_FILE_PATH: \"/tmp/microq/config.json\"\n    volumes:\n      - microq_volume:/tmp/microq\n    ports:\n      - 8080:8080\n      - 5000:5000\nvolumes:\n  microq_volume:\n    external: true\n</code></pre>"},{"location":"source-build/","title":"Building from source","text":"<p>microq can be built from source on Linux, Windows, or macOS.</p>"},{"location":"source-build/#prerequisites","title":"Prerequisites","text":"<ul> <li>Git</li> <li>Golang 1.15 or newer</li> </ul>"},{"location":"source-build/#building","title":"Building","text":"<pre><code>git clone https://github.com/c16a/microq.git\ncd microq\ngo build -ldflags=\"-s -w\" -o binary github.com/c16a/microq/app\n</code></pre>"},{"location":"source-build/#cross-compiling","title":"Cross compiling","text":"<p>To cross compile the microq binary to a different architecture or operating system, the <code>GOOS</code> and <code>GOARCH</code> environment variables can be used. <pre><code># List all available os/arch combinations for cross compiling\ngo tool dist list\n\n# To compile the binary for Linux ARM 64-bit, use the below\nGOOS=linux GOARCH=arm64 go build -ldflags=\"-s -w\" -o binary_amd64 github.com/c16a/microq/app\n</code></pre></p>"}]}